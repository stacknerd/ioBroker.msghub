{
  "BridgeAlexaShopping": {
    "md": "### What it does\n\n- Creates and maintains one Message Hub message (`kind: shoppinglist`) representing your Alexa list.\n- Keeps changes in sync:\n  - Alexa → Message Hub (ingest)\n  - Message Hub → Alexa (write-back)\n- Optional: assigns a `category` to list items using Message Hub AI (when enabled).\n\nWhat it intentionally does not do (today):\n\n- It does not aggregate duplicates like “Butter” + “Butter” into a single item with a quantity.\n- It does not try to be a perfect natural-language parser; it uses a small locale-specific lexicon and a few robust patterns.\n\nWhat it does do:\n\n- It can parse quantities/units from item text (e.g. “6x Butter 500g”) and stores them as structured fields:\n  - `listItems.quantity` (count/packaging)\n  - `listItems.perUnit` (mass/volume per item)\n\n### Prerequisites\n\n- `iobroker.alexa2` must be installed and running.\n- You need an Alexa list state that contains the list as a JSON array, typically:\n  - `alexa2.0.Lists.<LISTNAME>.json`\n- For write-back, your `alexa2` installation must expose the command states derived from that list id (see below).\n\nIf you want AI categories:\n\n- The Message Hub adapter must have AI enabled in its instance config (provider + API key).\n- The plugin option `aiEnhancement` must be enabled.\n\n### Quick start (recommended setup)\n\n1. Make sure the Alexa list JSON state exists and contains an array (in ioBroker Admin → Objects).\n2. Create one `BridgeAlexaShopping` instance in the Message Hub Plugins tab.\n3. Set:\n   - `jsonStateId` to your Alexa list JSON state\n   - `listTitle` to a human-friendly name\n   - `fullSyncIntervalMs` to something reasonable (example: `3600000` = 1 hour)\n4. Enable the plugin instance (`...enable` switch).\n5. Watch the resulting Message Hub message:\n   - Items from Alexa should appear as `listItems`.\n6. Test write-back:\n   - Add an item in the Message Hub list → it should appear in Alexa after the next sync.\n\n### How to configure\n\nConfiguration is done in the Message Hub Admin Tab (Plugins) and uses the schema from `lib/BridgeAlexaShopping/manifest.js`.\n\nRequired / common options:\n\n- `jsonStateId` (string)\n  - The Alexa list JSON state (example: `alexa2.0.Lists.SHOP.json`).\n  - This single option also determines the write-back command ids (derived from `jsonStateId` without the `.json` suffix).\n- `listTitle` (string)\n  - The Message Hub message title.\n- `location` (string)\n  - Written to `details.location` of the message.\n- `audienceTagsCsv` (string, CSV)\n  - Inbound (Alexa → MsgHub): comma-separated tags copied to `audience.tags`.\n- `audienceChannelsIncludeCsv` / `audienceChannelsExcludeCsv` (string, CSV)\n  - Inbound (Alexa → MsgHub): copied to `audience.channels.include` / `audience.channels.exclude`.\n- `fullSyncIntervalMs` (number)\n  - Periodic full reconciliation interval; `0` disables the periodic run.\n- `pendingMaxJsonMisses` (number)\n  - How many Alexa JSON updates are allowed before a pending \"create\" is retried.\n- `keepCompleted` (number, ms)\n  - Retention time for completed items.\n  - After this duration, completed items are deleted (in Message Hub and therefore also in Alexa).\n  - Use `0` to never delete completed items.\n\nAI options:\n\n- `aiEnhancement` (boolean)\n  - Enables optional AI enrichment (category assignment).\n- `categoriesCsv` (string, CSV)\n  - The list of allowed categories.\n  - The last entry is treated as the fallback category.\n- `aiMinConfidencePct` (number)\n  - Minimum confidence (0..100) for accepting an AI category.\n  - When below this threshold, the fallback category is used.\n\n### How to find the correct `jsonStateId`\n\nIn ioBroker Admin:\n\n- Open the Objects tab.\n- Search for `alexa2.0.Lists.` and look for states ending in `.json`.\n- Pick the list you want to sync (example: `alexa2.0.Lists.SHOP.json`).\n\nThe value must be a JSON array of items with (at least) `id`, `value`, and `completed` fields. If it is not an array,\nthe plugin treats it as empty.\n\n### Write-back (how Alexa commands are addressed)\n\nWrite-back uses `setForeignState(...)` to these ids (derived from `jsonStateId`):\n\nLet `base = jsonStateId` without the trailing `.json`.\n\n- Create: `base.#New` or `base.#create` (value = item text; the plugin auto-detects which command state exists)\n- Rename: `base.items.<itemId>.value` (value = new text)\n- Toggle completion: `base.items.<itemId>.completed` (value = `true|false`)\n- Delete: `base.items.<itemId>.#delete` (value = `true`)\n\nExample for `jsonStateId = alexa2.0.Lists.SHOP.json`:\n\n- `alexa2.0.Lists.SHOP.#New` (or `alexa2.0.Lists.SHOP.#create`)\n- `alexa2.0.Lists.SHOP.items.<itemId>.value`\n- `alexa2.0.Lists.SHOP.items.<itemId>.completed`\n- `alexa2.0.Lists.SHOP.items.<itemId>.#delete`\n\n### How to verify write-back is working\n\nUse ioBroker Admin → Objects:\n\n- Check that the derived command states exist under the same list base (without `.json`).\n- When you add or change an item in Message Hub, you should see writes to:\n  - `...#New` (or `...#create`) for new items\n  - `...items.<id>.value` for renames\n  - `...items.<id>.completed` for check/uncheck\n  - `...items.<id>.#delete` for deletions\n\nIf these command states do not exist in your `alexa2` installation, Message Hub can still read the list, but cannot\nwrite back to Alexa.\n\n### Best practices\n\n- Prefer one plugin instance per Alexa list.\n- Keep `jsonStateId` stable. Changing it changes the message `ref` and resets the mapping for that instance.\n- Use `fullSyncIntervalMs` even when state-change events are working:\n  - It acts as a periodic reconciliation and helps recover from missed events or temporary connectivity issues.\n- Keep completed-item cleanup explicit:\n  - Use `keepCompleted=0` to keep completed items forever.\n  - Use a finite value (example: `12 * 60 * 60 * 1000`) to automatically delete completed items after that time.\n  - Deletion is enforced during reconciliation (`fullSyncIntervalMs`) and on inbound list updates.\n- Avoid manual edits to internal states:\n  - `msghub.0.BridgeAlexaShopping.<instanceId>.mapping`\n  - `msghub.0.BridgeAlexaShopping.<instanceId>.categories`\n  These states are intentionally marked read-only (for users); the adapter still writes to them internally.\n- Conflicts and loops:\n  - Value formatting is one-way (MsgHub → Alexa). Inbound sync accepts completion changes and deletions as signal, while MsgHub remains the source of truth for item text/structure.\n- AI categories:\n  - If `aiEnhancement` is enabled in the plugin but AI is disabled in the adapter instance config, category assignment is skipped (no errors; it just does nothing).\n  - Keep `categoriesCsv` small and stable. Changing the list resets the learned cache for that plugin instance.\n  - Pick categories that match how you actually shop. Example set:\n    - `Produce,Bakery,Dairy,Meat,Frozen,Pantry,Drinks,Household,Hygiene,Other`\n\n### Operational notes\n\n- Disable behavior:\n  - When you disable the plugin instance, the Message Hub message is kept.\n  - The title is updated with a “connection lost” suffix (to make the inactive state visible).\n- Managed state reporting:\n  - The plugin reports the monitored `jsonStateId` as a managed state (metadata stamping + watchlist) so you can see\n    which external state is used by this plugin instance.\n\n### Troubleshooting\n\nCommon symptoms and what to check:\n\n- “Nothing appears in Message Hub”\n  - Verify `jsonStateId` exists and contains a JSON array.\n  - Check whether the plugin instance is enabled and running.\n  - Trigger a manual change in the Alexa list and confirm the `.json` state updates.\n\n- “Items appear in Message Hub but do not write back to Alexa”\n  - Verify the derived command states exist (see “Write-back” section).\n  - Check adapter logs for warnings about `setForeignState` failures.\n\n- “Items oscillate / ping-pong between values”\n  - Reduce other automations that write to the same Alexa list, or ensure they do not fight Message Hub.\n\n- “AI categories do not show up”\n  - Confirm AI is enabled in the Message Hub adapter instance config and a valid API key is set.\n  - Confirm `aiEnhancement=true` and `categoriesCsv` is not empty in the plugin instance config.\n  - Note: AI categorization is best-effort; if AI is unavailable, syncing still works (without categories).\n\n---",
    "source": "docs/plugins/BridgeAlexaShopping.md"
  },
  "BridgeAlexaTasks": {
    "md": "### What it does\n\n- Imports new Alexa TODO items into Message Hub as tasks (Alexa → Message Hub).\n- Mirrors a filtered subset of Message Hub messages back into the Alexa TODO list (Message Hub → Alexa).\n- Optional: generates a concise title for imported tasks using Message Hub AI (when enabled).\n\nWhat it intentionally does not do:\n\n- It does not sync edits from Alexa back into Message Hub for mirrored tasks (Alexa is display-only for outbound items).\n- It does not attempt to preserve lifecycle semantics on the Alexa side (Alexa does not have Message Hub lifecycle states).\n\n### Prerequisites\n\n- `iobroker.alexa2` must be installed and running.\n- You need an Alexa list state that contains the list as a JSON array, typically:\n  - `alexa2.0.Lists.<LISTNAME>.json` (default: `alexa2.0.Lists.TODO.json`)\n- For write-back (mirroring), your `alexa2` installation must expose the command states derived from that list id (see below).\n\nIf you want AI titles:\n\n- The Message Hub adapter must have AI enabled in its instance config (provider + API key).\n- The plugin option `aiEnhancedTitle` must be enabled.\n\n### Quick start (recommended setup)\n\n1. Make sure the Alexa TODO list JSON state exists and contains an array (in ioBroker Admin → Objects).\n2. Create one `BridgeAlexaTasks` instance in the Message Hub Plugins tab.\n3. Set:\n   - `jsonStateId` to your Alexa list JSON state\n   - `fullSyncIntervalMs` to something reasonable (example: `3600000` = 1 hour)\n   - `outEnabled` depending on whether you want mirroring back to Alexa\n4. Enable the plugin instance (`...enable` switch).\n5. Add an item in Alexa:\n   - It should appear in Message Hub as a new `task` message.\n   - It should then be deleted from the Alexa TODO list (inbox semantics).\n\n### How to configure\n\nConfiguration is done in the Message Hub Admin Tab (Plugins) and uses the schema from `lib/BridgeAlexaTasks/manifest.js`.\n\nCommon options:\n\n- `jsonStateId` (string)\n  - The Alexa list JSON state (example: `alexa2.0.Lists.TODO.json`).\n  - This single option also determines the write-back command ids (derived from `jsonStateId` without the `.json` suffix).\n- `fullSyncIntervalMs` (number)\n  - Periodic full reconciliation interval; `0` disables the periodic run.\n- `pendingMaxJsonMisses` (number)\n  - How many Alexa JSON updates are allowed before a pending \"create\" is retried.\n- `audienceTagsCsv` (string, CSV)\n  - Inbound (Alexa → MsgHub): comma-separated tags copied to `audience.tags` for imported tasks.\n- `audienceChannelsIncludeCsv` / `audienceChannelsExcludeCsv` (string, CSV)\n  - Inbound (Alexa → MsgHub): copied to `audience.channels.include` / `audience.channels.exclude` for imported tasks.\n- `aiEnhancedTitle` (boolean)\n  - When enabled and AI is available, the plugin generates a concise title for imported tasks.\n\nOutbound mirroring (projection) options:\n\n- `outEnabled` (boolean)\n  - Enables mirroring tasks back to Alexa.\n  - If you disable it, the plugin removes all previously mirrored items from Alexa on the next reconciliation run.\n- `outKindsCsv` (string, CSV)\n  - Which message kinds may be mirrored (default `task`).\n- `outLevelMin` / `outLevelMax` (number)\n  - Inclusive message level range for mirroring.\n- `outLifecycleStatesCsv` (string, CSV)\n  - Allowed lifecycle states (default `open`).\n- `outAudienceTagsAnyCsv` (string, CSV)\n  - Optional tag filter: message must have at least one matching `audience.tags` entry.\n  - Messages with no tags (missing/empty `audience.tags`) are treated as “public” and are included as well.\n\nNote:\n\n- For `kind=task`, outbound mirroring only includes messages where `timing.startAt` is either missing (unscheduled) **or** set to a timestamp in the past (`startAt <= now`).\n- Outbound items in Alexa are always written with a leading `~` (tilde). These `~`-prefixed items are treated as plugin-owned projections.\n\n### How to find the correct `jsonStateId`\n\nIn ioBroker Admin:\n\n- Open the Objects tab.\n- Search for `alexa2.0.Lists.` and look for states ending in `.json`.\n- Pick the list you want to use (example: `alexa2.0.Lists.TODO.json`).\n\nThe value must be a JSON array of items with (at least) `id`, `value`, and `completed` fields. If it is not an array,\nthe plugin treats it as empty.\n\n### Write-back (how Alexa commands are addressed)\n\nWrite-back uses `setForeignState(...)` to these ids (derived from `jsonStateId`):\n\nLet `base = jsonStateId` without the trailing `.json`.\n\n- Create: `base.#New` or `base.#create` (value = item text; the plugin auto-detects which command state exists)\n- Rename/update: `base.items.<itemId>.value` (value = new text)\n- Mark completed: `base.items.<itemId>.completed` (value = `true|false`)\n- Delete: `base.items.<itemId>.#delete` (value = `true`)\n\n### How to verify write-back is working\n\nUse ioBroker Admin → Objects:\n\n- Check that the derived command states exist under the same list base (without `.json`).\n- When mirroring is enabled (`outEnabled=true`), you should see writes to:\n  - `...#New` (or `...#create`) for new mirrored items\n  - `...items.<id>.value` when a mirrored item changes\n  - `...items.<id>.#delete` when an item is removed from the projection\n\nIf these command states do not exist in your `alexa2` installation, Message Hub can still import tasks from Alexa,\nbut cannot mirror tasks back to Alexa.\n\n### Best practices\n\n- Use one plugin instance per Alexa list.\n- Keep `jsonStateId` stable for a plugin instance.\n- Use a periodic `fullSyncIntervalMs` even when state-change events are working:\n  - It acts as a reconciliation loop and helps recover from missed events.\n- Treat Alexa as a quick task inbox:\n  - Add tasks in Alexa, then manage them in Message Hub.\n- Keep the outbound filter narrow:\n  - Default idea: only `kind=task`, `level>=10`, `lifecycle=open`.\n\n### Operational notes\n\n- Inbound import semantics:\n  - If import succeeds, the plugin deletes the Alexa item.\n  - If import fails, the plugin marks the Alexa item as completed to avoid repeated imports.\n- Disabling outbound mirroring:\n  - When `outEnabled=false`, all previously mirrored items are removed from Alexa on the next reconciliation run.\n- Managed state reporting:\n  - The plugin reports the monitored `jsonStateId` as a managed state (metadata stamping + watchlist).\n\n### Troubleshooting\n\nCommon symptoms and what to check:\n\n- “Items in Alexa are not imported”\n  - Verify `jsonStateId` exists and contains a JSON array.\n  - Check whether the plugin instance is enabled and running.\n  - Trigger a manual change in the Alexa list and confirm the `.json` state updates.\n\n- “Mirroring to Alexa does not work”\n  - Verify the derived command states exist (see “Write-back” section).\n  - Confirm `outEnabled=true`.\n\n- “AI titles do not show up”\n  - Confirm AI is enabled in the Message Hub adapter instance config and a valid API key is set.\n  - Confirm `aiEnhancedTitle=true` in the plugin instance config.\n  - Note: AI enrichment is best-effort; importing still works without AI.\n\n---",
    "source": "docs/plugins/BridgeAlexaTasks.md"
  },
  "EngageTelegram": {
    "md": "### What it does\n\n- Sends Telegram messages for Message Hub `due` notifications (Pushover-like).\n- Renders message actions as Telegram **inline buttons** (menu entry + menu navigation).\n- Handles button clicks and executes the corresponding Message Hub action (`ack/close/delete/snooze`) by allow-list (`message.actions[]`).\n- Provides a minimal command entry point:\n  - `/start` replies with a short help message.\n\n### What it intentionally does not do (today)\n\n- It does not create *new* Telegram notifications for `updated/recovered/recreated` events (it only syncs text/buttons and sends newly added image attachments).\n- It does not implement a rich chat bot command set (this is intentionally kept modular and small).\n\n### Prerequisites\n\n- ioBroker Telegram adapter installed and configured.\n- The Telegram adapter instance must provide:\n  - `sendTo('<telegramInstance>', 'send', ...)`\n  - The communicate states:\n    - `<telegramInstance>.communicate.request`\n    - `<telegramInstance>.communicate.requestChatId`\n    - `<telegramInstance>.communicate.requestMessageId`\n  - A `send` response that can be interpreted as a mapping `{ [chatId]: messageId }` (some adapter versions return this as JSON string or list).\n- For image attachments (`attachments[].type === 'image'`), the Telegram adapter must support sending photo messages via `send` payload field `photo` (plus optional `caption`).\n  - If you run an older Telegram adapter that does not support this, image attachments will not be delivered (and therefore also cannot be auto-deleted later).\n\n### Quick start (recommended setup)\n\n1. Create one `EngageTelegram` instance in the Message Hub Plugins tab.\n2. Set `telegramInstance` to your Telegram adapter instance (example: `telegram.0`).\n3. Configure filters (level range, kinds, lifecycle filter) similar to `NotifyPushover`.\n4. Enable the plugin instance (`...enable`).\n5. Trigger a Message Hub `due` notification and confirm:\n   - a Telegram message is sent\n   - action buttons appear\n6. Click a button and confirm:\n   - the corresponding MsgHub action is executed\n   - the old Telegram message is cleaned up (buttons removed or message deleted, depending on your settings)\n\n### How to configure\n\nConfiguration is done in the Message Hub Admin Tab (Plugins) and uses the schema from `lib/EngageTelegram/manifest.js`.\n\nCommon options:\n\n- `telegramInstance` (string)\n  - Target adapter instance (example: `telegram.0`).\n- `kindsCsv` (string, CSV)\n  - Filter by `message.kind` (empty = allow all).\n  - In the Admin Tab UI this is shown as a multi-select, but it is stored as a CSV string in `native`.\n- `levelMin` / `levelMax` (number)\n  - Filter by `message.level` (inclusive).\n\n- `lifecycleStatesCsv` (string, CSV)\n  - Filter by `message.lifecycle.state` (empty = allow all).\n  - In the Admin Tab UI this is shown as a multi-select, but it is stored as a CSV string in `native`.\n- `audienceTagsAnyCsv` (string, CSV)\n  - If set, only messages with at least one matching `audience.tags[]` entry are sent.\n\nTelegram-specific behavior options:\n\n- `disableNotificationUpToLevel` (number)\n  - For `message.level <= disableNotificationUpToLevel`, outgoing Telegram sends use `disable_notification: true` (silent notifications).\n  - Above this level, `disable_notification: false`.\n- Gate options (optional):\n  - `gateStateId`, `gateOp`, `gateValue`, `gateBypassFromLevel`\n  - This is a **global** send/mute gate for the Telegram integration (useful for maintenance/quiet hours). It is not user-specific.\n- Menu action switches (booleans, default `true`):\n  - `enableAck`, `enableClose`, `enableSnooze`, `enableOpen`, `enableLink`\n  - These only affect which actions are shown in the Telegram menu; the core still enforces the action allow-list via `message.actions[]`.\n\nCommands:\n\n- Commands are fixed to `/...` and currently only `/start` is implemented.\n- The callback prefix is fixed to `opt_` (used internally for inline button callbacks).\n\n### Best practices\n\n- Start with a narrow filter:\n  - Use `levelMin` and `kindsCsv` to reduce noise.\n- Use silent notifications for low-severity messages:\n  - Keep `disableNotificationUpToLevel` at `info`/`10` if you want informational messages to be quiet.\n- Prefer deleting old notifications on resend:\n  - The plugin always deletes the old Telegram messages for a ref before sending the new `due` notification, to keep the chat clean.\n\n### Troubleshooting\n\nCommon symptoms and what to check:\n\n- “No Telegram messages are sent”\n  - Verify the plugin instance is enabled and running.\n  - Verify your filters (especially `levelMin/levelMax`).\n  - Confirm that Message Hub actually emits `due` notifications for your messages.\n\n- “Buttons show up, but clicks do nothing”\n  - Check adapter logs for `EngageTelegram.* inbound:` and `action:` debug lines.\n  - Verify the message contains the action id in `message.actions[]` (it is an allow-list).\n\n- “Text shows raw `<b>...</b>`”\n  - This points to Telegram adapter parsing differences (send/edit payload shape). The plugin uses HTML and escapes input.\n\n---",
    "source": "docs/plugins/EngageTelegram.md"
  },
  "IngestDwd": {
    "md": "### What it does\n\n- Reads warning objects from the `dwd` adapter (example instance `dwd.0`):\n  - `dwd.0.warning.object`\n  - `dwd.0.warning1.object` … `dwd.0.warning9.object`\n- Creates and maintains one Message Hub message (`kind: status`) per warning.\n- Removes the message again when the warning disappears from the DWD states (cause eliminated).\n- Optional: improves `title` / `text` / `details.task` via MsgHub AI (cached).\n\nWhat it intentionally does not do (today):\n\n- It does not try to deduplicate/merge overlapping warnings (warnings are kept 1:1).\n\n### Prerequisites\n\n- `iobroker.dwd` must be installed and running.\n- The DWD adapter must expose warning states (typically):\n  - `dwd.0.numberOfWarnings`\n  - `dwd.0.warning.object`, `dwd.0.warning1.object`, ...\n\nIf you want AI enhancement:\n\n- The Message Hub adapter must have AI enabled in its instance config (provider + API key).\n- The plugin option `aiEnhancement` must be enabled.\n\n### Quick start (recommended setup)\n\n1. Verify the DWD warning states exist (ioBroker Admin → Objects).\n2. Create one `IngestDwd` instance in the Message Hub Plugins tab.\n3. Set:\n   - `dwdInstance` to your DWD instance (example: `dwd.0`)\n   - optionally: altitude filter (`useAltitudeFilter`, `altitudeM`)\n   - optionally: `audienceTagsCsv` / `audienceChannelsIncludeCsv` / `audienceChannelsExcludeCsv`\n4. Enable the plugin instance (`...enable` switch).\n5. Trigger a test warning (or wait for a real one) and confirm a `status` message appears in Message Hub.\n\n### How to configure\n\nConfiguration is done in the Message Hub Admin Tab (Plugins) and uses the schema from `lib/IngestDwd/manifest.js`.\n\nCommon options:\n\n- `dwdInstance` (string)\n  - Source adapter instance (example: `dwd.0`).\n- `useAltitudeFilter` / `altitudeM` (boolean / number)\n  - Optional filter: only import warnings whose altitude range includes your altitude.\n- `audienceTagsCsv` (string, CSV)\n  - Comma-separated tags copied to `audience.tags`.\n- `audienceChannelsIncludeCsv` / `audienceChannelsExcludeCsv` (string, CSV)\n  - Copied to `audience.channels.include` / `audience.channels.exclude`.\n- `titlePrefix` (string)\n  - Prefix prepended to the warning title (also applied to AI-enhanced titles). Default: `DWD: `.\n- `aiEnhancement` (boolean)\n  - Enables optional AI improvement for title/text/task (cached).\n- `keepCacheHistory` (number)\n  - `0` clears AI cache entries when a message expires/deletes (default).\n  - `> 0` keeps up to N cached entries for auditing (FIFO).\n- `syncDebounceMs` (number, ms)\n  - Debounce window for re-reading DWD warning objects after state changes.\n\n### Altitude filter\n\nWhen enabled, a warning is included when:\n\n- `altitudeStart` and `altitudeEnd` are both present and `altitudeStart <= altitudeM <= altitudeEnd` (inclusive), or\n- either altitude boundary is missing/null (treated as “always relevant”).\n\n### Actions created\n\nEach warning message includes:\n\n- `ack`\n- `snooze (1h)`\n\n### Operational notes\n\n- DWD warning slots can “move” between `warning`, `warning1`, …; the plugin does not rely on slot position.\n- When a warning disappears from the DWD states, `IngestDwd` calls `api.store.completeAfterCauseEliminated(...)`:\n  - for `kind: status` this removes (soft-deletes) the message.\n\n### Troubleshooting\n\nCommon symptoms and what to check:\n\n- “Nothing appears in Message Hub”\n  - Verify `dwdInstance` is correct (`dwd.0`, `dwd.1`, ...).\n  - Verify warning object states exist (e.g. `dwd.0.warning.object`) and contain non-empty objects (not `{}`).\n  - Check adapter logs for `IngestDwd` warnings about `getForeignState`.\n\n- “Warnings are missing because of altitude”\n  - Temporarily disable `useAltitudeFilter` to verify the upstream warning feed.\n  - Confirm your `altitudeM` is within the warning’s `altitudeStart/altitudeEnd` (inclusive).\n\n- “AI enhancement does not run”\n  - Confirm MsgHub AI is enabled in the adapter instance config and has a valid API key.\n  - Confirm `aiEnhancement=true` in the plugin instance config.\n\n---",
    "source": "docs/plugins/IngestDwd.md"
  },
  "IngestRandomChaos": {
    "md": "### What it does\n\n- Periodically creates, updates, and removes a small pool of messages.\n- Generates both `task` and `status` messages with plausible lifecycle transitions.\n- Cleans up after itself on stop by soft-deleting messages it managed in the current run.\n\nWhat it intentionally does not do:\n\n- It is not deterministic and not a strict simulator.\n- It does not try to cover every message feature (for example no `listItems`, `actions`, `attachments`, ...).\n\n### Prerequisites\n\n- None. This plugin is self-contained and does not read foreign states.\n\n### Quick start (recommended setup)\n\n1. Create an `IngestRandomChaos` instance in the Message Hub Plugins tab.\n2. Keep the defaults or set reasonable values:\n   - `intervalMinMs=2000`\n   - `intervalMaxMs=5000`\n   - `maxPool=10`\n3. Enable the plugin instance (`...enable` switch).\n4. Watch the Message Hub message list and/or notifier outputs (for example `NotifyStates`).\n\n### How to configure\n\nConfiguration is done in the Message Hub Admin Tab (Plugins) and uses the schema from `lib/IngestRandomChaos/manifest.js`.\n\nOptions:\n\n- `intervalMinMs` (number, ms, default `2000`)\n  - Minimum delay between ticks.\n- `intervalMaxMs` (number, ms, default `5000`)\n  - Maximum delay between ticks (clamped to be `>= intervalMinMs`).\n- `maxPool` (number, default `10`)\n  - Maximum number of concurrently “active” messages managed by this plugin.\n\n### Best practices\n\n- Use this plugin for development/testing only; keep it disabled in production.\n- Keep `maxPool` small to avoid archive spam and to keep notifier/state churn manageable.\n- Pair it with notifier plugins (for example `NotifyStates`) to validate routing behavior.\n\n### Troubleshooting\n\n- “Nothing happens”\n  - Verify the plugin instance is enabled and running.\n  - Ensure `intervalMaxMs` is not accidentally set below `intervalMinMs`.\n\n- “Too many messages”\n  - Reduce `maxPool` and/or increase the intervals.\n\n---",
    "source": "docs/plugins/IngestRandomChaos.md"
  },
  "IngestStates": {
    "md": "### What IngestStates is for\n\nIngestStates is for “I want a message when …” monitoring on top of ioBroker datapoints.\n\nExamples:\n\n- “Warn me if the humidity goes outside 35–60%.”\n- “Warn me if a sensor has not reported anything for 12 hours.”\n- “When a valve turns on, I expect the water meter to increase within 10 minutes.”\n- “My value never settles / keeps drifting for too long.”\n- “Detect a session: started / ended (e.g. washing machine).”\n\n### How it works (mental model)\n\n- You pick a datapoint in ioBroker (**Objects**).\n- You attach a rule to it in **Custom** (for your `msghub.X` instance).\n- When the rule becomes true, MsgHub creates (or reuses) a message and keeps it up to date.\n- When the rule becomes normal again, MsgHub can remove the message automatically (recommended) or keep it until you close it manually.\n\n### Quick start\n\n1. Enable `IngestStates` in MsgHub Admin Tab → **Plugins**.\n2. In ioBroker Admin → **Objects**, open a datapoint and go to **Custom**.\n3. Enable the **MsgHub custom config** (example: `msghub.0`).\n4. In **Monitoring**, select a rule type and fill out the corresponding rule tab.\n5. In **Message**, decide how the message should look and behave (title/text/audience/reminders/auto-remove…).\n\n### Choosing the right rule type (quick decision help)\n\n- If the problem is “too high/too low / outside a range / wrong boolean”: use **Threshold**.\n- If the problem is “sensor does not report anymore”: use **Freshness**.\n- If the problem is “when A is active, B must react within time X”: use **Dependency (Trigger)**.\n- If the problem is “value never calms down / keeps trending for too long”: use **Non-settling**.\n- If you want “started / ended” behavior: use **Session**.\n\n### Messages: “store truth” vs “notifications”\n\nMsgHub keeps a message in its store (so you can see the problem state), and it can also notify you.\nThese are related but not identical:\n\n- A message can be **open** in the store without constantly notifying you (e.g. snoozed, cooldown, reminders off).\n- A message can update silently (metrics updates) without producing notification noise.\n\n### Actions (buttons) you can use\n\nActions are defined by the rule (not by a per-object “actions” setting):\n\n- **Ack**: “I saw it.” The message stays as-is; IngestStates does not “re-open” it just because the condition is still true.\n- **Snooze (4h)**: suppresses notifications for 4 hours (the message can still be updated silently).\n- **Close**: offered automatically when auto-remove is disabled, so you can always get rid of a message.\n- **Delete**: used only for the *session start* message (so you can permanently dismiss it during the running session).\n\n### Shared “Message” settings (what they mean)\n\nThese settings apply to all rule types:\n\n- **Kind / Level**\n  - Kind: usually “status” (a condition) or “task” (something to do).\n  - Level: notice / warning / error (how important is it).\n- **Task planning (only for Kind = “task”)**\n  - **Estimated time**: stores an estimate for how long the task will take.\n  - **Due in**: sets a due date relative to “now” when the message is created.\n- **Title / Text (optional)**\n  - If you leave them empty, the rule provides a helpful default text.\n  - If you provide your own text, it is used as-is.\n- **Audience (optional)**\n  - Tags and Channels are comma-separated lists (CSV). Use this to send different messages to different integrations/users.\n- **Reminder**\n  - Optional repeated notifications while the issue stays active.\n  - Use this for “still broken” reminders, not for high-frequency telemetry.\n- **Back to normal**\n  - “Auto-remove message(s)” closes the message automatically when the condition becomes normal again.\n  - Optional “Delay” helps against flapping (briefly normal → briefly bad → normal…).\n- **Cooldown**\n  - After a message was closed, cooldown prevents “close → instant reopen → notify again” spam.\n  - Important: cooldown does not “hide valid warnings” in the store. If the condition returns during cooldown, MsgHub keeps the store truthful and delays/avoids the next notification.\n\nPractical recommendation (good defaults to start with):\n\n- Keep **Auto-remove** enabled for most rules.\n- Use a small **Delay** (e.g. 1–5 minutes) if your source flaps.\n- Use **Cooldown** if you see a lot of “close → reopen” noise.\n\n### Location (room) auto-detection\n\nIf your datapoint is assigned to an ioBroker room (`enum.rooms.*`), IngestStates stores the room name as\n`Location` in the message details. This can help notification integrations and UI grouping.\n\n### Writing your own text (optional, advanced)\n\nSome rule defaults (and your own texts) can include placeholders like:\n\n- `{{m.state-value}}` (current value)\n- `{{m.lastSeenAt|datetime}}` (timestamp as date/time)\n- `{{m.lastSeenAt|durationSince}}` (“how long ago”)\n\nFormatting note for `durationSince` / `durationUntil`:\n\n- `< 1min`: `56s`\n- `< 1h`: `34m` (rounded)\n- `< 1 day`: `3:45h` (rounded)\n- `>= 1 day`: `1d 4h` (rounded)\n\nTip: start with defaults. Only customize title/text once the rule behavior is correct.\n\n---\n\n## 1.1 Rule types (explained with examples)\n\n### Threshold (value outside a limit/range)\n\nUse Threshold when “the value should be inside a limit/range, otherwise alert”.\n\nTypical use cases:\n\n- Battery below 10%\n- Humidity outside 35–60%\n- Window contact is TRUE for too long (boolean)\n\nHow it behaves:\n\n- When the value enters the “bad” area, a message appears (immediately or after an optional minimum duration).\n- While active, the message stores the latest value as a metric.\n- When the value returns to normal, the message is closed automatically (if enabled) or stays until you close it.\n\nOptions you will see in the Threshold tab:\n\n- **Condition type**\n  - “Too low / Too high” (single limit)\n  - “Outside / Inside range” (two limits)\n  - “Boolean TRUE/FALSE” (useful for contacts, switches, errors)\n- **Hysteresis**\n  - Adds a “buffer zone” to avoid flapping around the boundary.\n  - Example (too high): alert above 50, but clear only when value goes below 48.\n- **Minimum duration**\n  - “Condition must stay bad for X before creating the message.”\n  - This avoids short spikes.\n\nWhat “back to normal” means here:\n\n- For numeric limits/ranges, the value must cross the “safe side” again (with hysteresis, the safe side is slightly wider).\n- For boolean conditions, it must become the opposite value (TRUE → FALSE, or FALSE → TRUE).\n\nHow to tune it (common patterns):\n\n- **Flapping around a boundary** → increase hysteresis, or add a reset delay (Message tab).\n- **Short spikes** → use minimum duration.\n- **You want a human-friendly message** → start with defaults, then adjust title/text once you like the behavior.\n\nPractical examples:\n\n- Humidity outside 35–60%, hysteresis 2%: the message clears only once it is clearly back inside.\n- Power above 500W for at least 5 minutes: avoids “short kettle spike” alerts.\n\n### Freshness (no update / no change for too long)\n\nUse Freshness when the datapoint should be “alive”, and missing updates likely mean “sensor offline” or “adapter stuck”.\n\nTwo variants:\n\n- **No update**: alert if the datapoint did not receive any update for X.\n- **No value change**: alert if the *value* did not change for X (useful when devices only report on change).\n\nHow to choose between “update” and “change”:\n\n- If the device sends keepalives (updates even when the value stays the same) → use **No update**.\n- If the device only sends values when they change → use **No value change**.\n- If you are unsure: look at the datapoint’s “last update” vs “last change” timestamps in ioBroker.\n\nHow it behaves:\n\n- IngestStates tracks the last update/change timestamp.\n- When the “age” exceeds your configured threshold, a message is opened.\n- When a new update/change arrives, the message is closed (if configured).\n\nImportant note:\n\n- Freshness needs periodic evaluation. If the plugin’s global “Evaluate interval” is set to `0` (event-only),\n  Freshness will not create alerts because it has no tick to compare “now vs last update”.\n\nExamples:\n\n- Temperature sensor: “at least one update every 12 hours”\n- Heartbeat / keepalive: “at least once every 5 minutes”\n\n### Dependency (Trigger): “When A happens, B must react”\n\nUse this rule when one datapoint acts as a “trigger”, and another datapoint must react within a time window.\n\nExamples:\n\n- Valve turns ON → water meter must increase within 10 minutes\n- Plug turns ON → power must become >= 5W within 30 seconds\n- Heating turns ON → flow temperature must rise by at least 2°C within 15 minutes\n\nHow it behaves:\n\n- The window starts **only when the trigger becomes active** (rising edge).\n- If the trigger becomes inactive before the window ends, the timer is cancelled and no message is created.\n- If the window ends and the expectation is not met, a message is opened.\n- If the expectation becomes true later, the message closes via your normal “Back to normal” settings.\n\nHow to configure it (in simple terms):\n\n- Pick the **trigger datapoint** (the one that “starts the window”).\n- Decide what “trigger is active” means:\n  - simplest: “trigger is truthy” (on/off, motion, enable flags)\n  - advanced: “trigger equals X / greater than X / less than X”\n- Choose the **time window** (how long you give the system to react).\n- Choose the **expected reaction** of the monitored datapoint:\n  - “it changed” (value change)\n  - “it increased/decreased by at least …”\n  - “it reached at least / at most …”\n\nCommon pitfalls:\n\n- If you choose “greater/less than”, the trigger value must be numeric (strings like `\"12\"` still work; non-numeric does not).\n- Choose a window that matches real-world latency (slow devices and adapter schedules can easily need minutes).\n\nExample (valve → meter):\n\n- Trigger datapoint: `valveState`\n- Trigger active: “truthy”\n- Window: `10 minutes`\n- Expectation: “increased by at least 1” (delta up)\n\nIf the valve turns on, but the meter does not move within 10 minutes, you get a message.\nWhen the meter finally moves, the message can close automatically (if auto-remove is enabled).\n\n### Non-settling value (never stable / unexpected trend)\n\nUse this when the problem is not “too high/low”, but “the value behaves oddly for a long time”.\n\nThere are two profiles:\n\n#### Profile “Activity” (never becomes stable)\n\nUse when the value keeps moving/fluctuating and never reaches a stable phase.\n\nYou control:\n\n- What counts as a relevant change (minimum delta)\n- How long continuous activity is tolerated (max continuous)\n- How long it must stay “quiet” to be considered stable (quiet gap)\n\nThe message is opened when the value has been continuously “not stable” for longer than the max duration.\nThe message is cleared when the value becomes stable again (quiet phase long enough).\n\nExample (activity):\n\n- Datapoint: `humidity`\n- Minimum delta: `1` (ignore tiny noise)\n- Quiet gap: `10 min` (must be calm for 10 min to count as stable)\n- Max continuous: `6 h` (alert if it never calms down for 6 hours)\n\nHow to tune:\n\n- If you get alerts too early → increase max continuous.\n- If it never clears even though it looks stable → increase quiet gap or increase minimum delta (noise).\n\n#### Profile “Trend” (keeps rising or falling)\n\nUse when the value keeps moving in one direction for too long.\n\nYou control:\n\n- Direction (up / down / any)\n- How long the trend must persist (trend window)\n- How much total movement must happen before it counts (minimum total delta)\n\nTip:\n\n- If “no more updates” should be treated as a problem, combine this rule with **Freshness** (they solve different problems).\n\nExample (trend):\n\n- Datapoint: `waterMeter`\n- Direction: `up`\n- Trend window: `30 min`\n- Minimum delta: `0.1` (ignore tiny counter wobble)\n- Minimum total delta: `5` (alert only if there was meaningful movement)\n\nImportant note:\n\n- This rule clears based on new incoming values (a “broken trend”), not based on silence. If the device stops reporting,\n  the rule does not treat that as “back to normal” (use Freshness for missing updates).\n\n### Session (Start/Stop): “Detect a run and summarize”\n\nUse Session when you want a start/end message for a process that can be detected from a “power” datapoint.\n\nTypical examples:\n\n- Washing machine / dishwasher cycle\n- Pump run\n- Heating cycle (with a power threshold)\n\nHow it behaves:\n\n- Start: power rises above the start threshold (optionally must stay above it for a minimum hold time).\n- End: power falls below the stop threshold (optionally must stay below it for a stop delay).\n- Optional gate: a separate on/off datapoint can enable/disable monitoring; switching the gate off ends a running session.\n- Optional counter + price datapoints can be used to calculate session consumption/cost metrics.\n\nOptions you will see in the Session tab:\n\n- **Gate (optional)**\n  - Lets you “enable/disable” monitoring from another datapoint (e.g. a mode switch).\n  - If the gate turns off during a running session, the session ends.\n- **Start threshold + start hold (optional)**\n  - The value must rise above the threshold to be considered “started”.\n  - Start hold requires it to stay above the threshold for a minimum time (debounce).\n- **Stop threshold + stop delay (optional)**\n  - The value must fall below the threshold to be considered “ended”.\n  - Stop delay requires it to stay below the threshold for a minimum time (debounce).\n- **Cancel stop when value rises again**\n  - Prevents false “end” detections when the value briefly dips below the stop threshold.\n- **Energy counter + price (optional)**\n  - Lets MsgHub compute “consumed” and “cost” metrics for the end message.\n  - Units are taken from the datapoints themselves (could be anything, not just kWh / €).\n\nMessages:\n\n- End message: always created on session end.\n- Optional start message: can be created when the session begins.\n  - When the end message is created, the start message is soft-deleted (removed), not closed.\n  - When a new session starts, the previous end message is closed (cause eliminated) so it does not stay around forever.\n\nWhere to configure the start message:\n\n- In the **Message** tab, enable “Create start message” and fill out the separate start-message fields (title/text/audience/etc.).\n\nExample (washing machine):\n\n- Power datapoint: starts above `10 W`, ends below `3 W`\n- Start hold: `1 min` (avoid short bumps)\n- Stop delay: `10 min` (avoid “pause” ending the session)\n- Optional counter datapoint: energy meter\n- Optional price datapoint: price per unit\n\n---\n\n## 1.2 Troubleshooting (common issues)\n\n- “Nothing happens”\n  - Verify the `IngestStates` plugin instance is enabled and running.\n  - Verify the object has the MsgHub custom config enabled (Objects → Custom).\n  - Verify the “Monitoring” rule type is selected and the rule is enabled.\n  - If you use Freshness: make sure the plugin’s “Evaluate interval” is not `0`.\n- “My rule tabs are hidden”\n  - The object might be marked as “managed” by another source. In that case, MsgHub hides manual rules.\n  - Exception: if `managedBy` contains `IngestStates.<instanceId>`, the UI stays visible for editing.\n- “Threshold never triggers”\n  - Ensure the datapoint value is numeric (strings like `\"42\"` are okay; non-numeric strings are ignored).\n- “It triggered once and never went away”\n  - Check “Back to normal” settings. If auto-remove is disabled, you must close manually.\n  - If you configured a reset delay: keep a non-zero evaluate interval so restart-safe closing can run.\n- “I see a lot of ‘close → reopen’ noise”\n  - Add a reset delay (Back to normal) and/or enable cooldown.\n  - Consider hysteresis / minimum duration for Threshold rules.\n- “It reopened, but I did not get a notification”\n  - That is expected during cooldown: the store becomes open again, but notifications can be delayed/suppressed.\n\n---",
    "source": "docs/plugins/IngestStates.md"
  },
  "NotifyDebug": {
    "md": "### What it does\n\n- Logs plugin lifecycle (`start(ctx)`, `stop(ctx)`) when trace is enabled.\n- Logs every notification batch received via `onNotifications(event, notifications, ctx)`.\n- Does not deliver anything and does not modify the Message Hub store.\n\n### Prerequisites\n\n- None. You only need access to the Message Hub adapter logs.\n\n### Quick start (recommended setup)\n\n1. Create a `NotifyDebug` instance in the Message Hub Plugins tab.\n2. Set `trace=true`.\n3. Enable the plugin instance (`...enable` switch).\n4. Trigger a notification (for example by creating/updating a message) and watch the adapter logs.\n\n### How to configure\n\nConfiguration is done in the Message Hub Admin Tab (Plugins) and uses the schema from `lib/NotifyDebug/manifest.js`.\n\nOptions:\n\n- `trace` (boolean, default `false`)\n  - Enables debug logs for start/stop and dispatches.\n- `someText` (string, default `\"\"`)\n  - Optional demo value logged at startup.\n\n### Best practices\n\n- Keep this plugin disabled in production; it can produce noisy logs.\n- Use it temporarily when developing other plugins or diagnosing notification routing.\n\n### Troubleshooting\n\n- “No logs”\n  - Verify `trace=true` and the plugin instance is enabled and running.\n  - Check adapter log level; `NotifyDebug` uses `debug` and `info`.\n\n---",
    "source": "docs/plugins/NotifyDebug.md"
  },
  "NotifyPushover": {
    "md": "### What it does\n\n- Sends Message Hub notifications (`event: \"due\"`) to `iobroker.pushover` (or compatible) via `sendTo('<pushover.0>', 'send', payload)`.\n- Filters which messages are sent (kind, level range, lifecycle states, audience tags).\n- Optional: blocks delivery behind a gate state (presence/arming/etc.).\n- If a message has image attachments, sends one additional low-priority Pushover message per image.\n\nWhat it intentionally does not do:\n\n- It does not send `added/updated/deleted/expired` events (only `due`).\n- It does not implement rate limiting or “spam protection”.\n- It does not download images: only local plain file paths are accepted for image attachments.\n\n### Prerequisites\n\n- A running Pushover adapter instance (example: `pushover.0`) with working credentials.\n- Message Hub must be running and the plugin instance must be enabled.\n\n### Quick start (recommended setup)\n\n1. Create one `NotifyPushover` instance in the Message Hub Plugins tab.\n2. Set:\n   - `pushoverInstance` to your adapter instance (default: `pushover.0`)\n   - optionally: filters (`kindsCsv`, `levelMin/max`, `audienceTagsAnyCsv`)\n3. Optional gate:\n   - set `gateStateId` and a `gateOp` (and `gateValue` if needed)\n4. Enable the plugin instance (`...enable` switch).\n5. Make a message due (or create one without `timing.notifyAt`) and verify the Pushover notification arrives.\n\n### How to configure\n\nConfiguration is done in the Message Hub Admin Tab (Plugins) and uses the schema from `lib/NotifyPushover/manifest.js`.\n\nTarget:\n\n- `pushoverInstance` (string)\n  - The adapter instance to call via `sendTo`, e.g. `pushover.0`.\n\nMessage filters (all optional; empty = allow all):\n\n- `kindsCsv` (string, CSV)\n  - Filters by `message.kind` (example: `task,status,appointment`).\n  - In the Admin Tab UI this is shown as a multi-select, but it is stored as a CSV string in `native`.\n- `levelMin` / `levelMax` (number)\n  - Inclusive level range.\n- `audienceTagsAnyCsv` (string, CSV)\n  - If set, only messages with at least one matching `audience.tags` entry are sent.\n\n- `lifecycleStatesCsv` (string, CSV)\n  - Filters by `message.lifecycle.state` (empty = allow all).\n  - In the Admin Tab UI this is shown as a multi-select, but it is stored as a CSV string in `native`.\n\nPriority mapping (fixed):\n\n- `none` / `info`: `-2` (no notification)\n- `notice`: `-1` (quiet / no sound)\n- `warning` / `error`: `0` (normal)\n- `critical`: `1` (high; bypass quiet hours)\n\nGate (optional):\n\n- `gateStateId` (string)\n  - A foreign state id used as a gate (example: presence state).\n- `gateOp` (string)\n  - One of: `>`, `<`, `=`, `true`, `false`.\n  - Empty disables the gate.\n- `gateValue` (string)\n  - Comparison value for `>`, `<`, `=` (numeric or string).\n  - Ignored for `true` / `false`.\n- `gateBypassFromLevel` (number)\n  - If `message.level >= gateBypassFromLevel`, the gate is bypassed and the notification is always sent.\n  - Default: `50` (critical).\n\n### How to find the correct `pushoverInstance`\n\nIn ioBroker Admin:\n\n- Open the Instances tab.\n- Find your Pushover adapter instance.\n- Use the instance id as value (example: `pushover.0`).\n\n### Gate examples\n\nPresence boolean gate (only send when `true`):\n\n- `gateStateId = some.0.presence`\n- `gateOp = true`\n\nNumeric threshold gate (only send when value is greater than 0):\n\n- `gateStateId = some.0.presenceCount`\n- `gateOp = >`\n- `gateValue = 0`\n\n### Troubleshooting\n\n- “No notifications arrive”\n  - Verify the plugin instance is enabled and `Status` is `running`.\n  - Verify your Pushover adapter instance can receive `sendTo(..., 'send', ...)` commands (test with an existing script).\n  - Confirm messages are actually dispatched as `due` (Message Hub may treat missing `notifyAt` as “due now”).\n\n- “Images do not arrive”\n  - Only attachments with `type: \"image\"` and a local plain file path (`value` without `://`) are sent.\n  - URLs are ignored by design.\n\n---",
    "source": "docs/plugins/NotifyPushover.md"
  },
  "NotifyShoppingPdf": {
    "md": "### What it does\n\n- Listens to MsgHub notifications for `shoppinglist` messages (`added`, `updated`, `deleted`, `expired`).\n- Regenerates a single combined PDF (debounced/throttled via `renderDebounceMs`).\n- Stores the PDF in ioBroker file storage under `msghub.0/documents/NotifyShoppingPdf.<instanceId>.pdf`.\n\n### What it intentionally does not do\n\n- No fallbacks outside the MsgHub runtime (`IoPlugins`): it expects `ctx.api.*` capabilities and the adapter environment.\n- No PDF rendering without LaTeX: `pdflatex` must be available.\n- No sorting: shopping lists and items are rendered “as delivered” by MsgHub.\n\n### Prerequisites\n\n- `pdflatex` must be installed and available on `PATH`.\n- The LaTeX template uses packages like `tcolorbox`, `multicol`, `tabularx`, `fancyhdr`, `lastpage` (Debian often needs `texlive-latex-extra`).\n- The Message Hub adapter must be running and have shopping list messages (`kind: shoppinglist`) in the store.\n\nIf `pdflatex` is missing, the plugin fails to start and the instance stays in `error`.\n\nExample (Debian):\n\n```sh\nsudo apt-get install texlive-latex-base texlive-latex-extra\n```\n\n### Output location (ioBroker file storage)\n\nThe plugin writes one PDF per plugin instance:\n\n- `msghub.0/documents/NotifyShoppingPdf.<instanceId>/<pdfTitle>.pdf`\n\nExample:\n\n- `msghub.0/documents/NotifyShoppingPdf.0/Einkaufsliste.pdf`\n\nYou can view/download it via ioBroker Admin → Files (or any integration that can read adapter file storage).\n\n### States written by the plugin\n\nAfter every successful generation, the plugin writes two states below its instance subtree:\n\n- `msghub.0.NotifyShoppingPdf.<instanceId>.pdfPath`\n  - Value: `msghub.0/documents/NotifyShoppingPdf.<instanceId>/<pdfTitle>.pdf`\n- `msghub.0.NotifyShoppingPdf.<instanceId>.pdfUrl`\n  - Best-effort URL to the PDF:\n    - If `web.0` is detected: `http(s)://<host>:<port>/files/msghub.0/documents/...`\n    - Otherwise: `/files/msghub.0/documents/...` (relative path)\n\n### Configuration\n\nConfiguration is done in the Message Hub Admin Tab (Plugins) and uses the schema from `lib/NotifyShoppingPdf/manifest.js`.\n\nCommon options:\n\n- `includeChecked` (boolean; default `true`)\n  - When enabled, checked items are included (rendered greyed out).\n- `audienceTagsAnyCsv` (string CSV; default empty)\n  - Comma-separated audience tags to include.\n  - If set, only shopping lists with at least one matching `audience.tags[]` entry are included.\n- `renderDebounceMs` (number; default `1000`)\n  - Debounce window for regenerating the PDF when notifications arrive.\n- `printRoomLabelsFromItems` (number; default `6`)\n  - Prints `listItem.category` section headings only when the list has more than this number of printed items.\n- `includeEmptyCategories` (boolean; default `true`)\n  - If disabled, lists with 0 printed items are omitted from the PDF.\n- `design` (string; default `print`)\n  - `screen` uses lighter lines; `print` uses stronger lines.\n- `notesLines` (number; default `5`)\n  - Adds a localized “NOTES/NOTIZEN” block at the end of the PDF (`0` disables it).\n\n### How the PDF layout maps to MsgHub data\n\n- **Category cards** in the PDF correspond to shopping list messages.\n  - `category` label = `message.title` (fallback: `message.ref`).\n- Inside each card, **rooms/sections** correspond to list item categories:\n  - `room.label` = `listItem.category` (fallback: `uncategorizedLabel`).\n- Each printed line corresponds to one `listItems[]` entry and shows a checkbox:\n  - `checked=false` → empty box\n  - `checked=true` → checkmark (and greyed out text if `includeChecked=true`)\n\nThe PDF subtitle is a localized “generated at” timestamp derived from `system.config.common.language`\n(example: `Sonntag, 04.01.2026 02:10`).\n\n---",
    "source": "docs/plugins/NotifyShoppingPdf.md"
  },
  "NotifyStates": {
    "md": "### What it does\n\n- Writes the most recent notification payload into ioBroker states, grouped by:\n  - event (`Latest.<event>`)\n  - kind (`byKind.<kindKey>.<event>`)\n  - level (`byLevel.<levelKey>.<event>`)\n- Optionally writes periodic snapshots of the full Message Hub store (`fullJson`).\n- Maintains simple counters (`Stats.*`) so you can build dashboards without parsing large JSON blobs.\n\nWhat it intentionally does not do:\n\n- It does not keep a history/log (each state is “last write wins”).\n- It does not deduplicate or aggregate notifications.\n\n### Prerequisites\n\n- None beyond a working Message Hub instance. The produced states can be consumed by scripts/visualizations/automations.\n\n### Quick start (recommended setup)\n\n1. Create a `NotifyStates` instance in the Message Hub Plugins tab.\n2. Enable the plugin instance (`...enable` switch).\n3. Inspect the generated states in ioBroker Admin → Objects under:\n   - `msghub.0.NotifyStates.<instanceId>.Latest.*`\n4. Trigger a notification (for example create/update a message) and observe state updates.\n\n### How to configure\n\nConfiguration is done in the Message Hub Admin Tab (Plugins) and uses the schema from `lib/NotifyStates/manifest.js`.\n\nChannel routing:\n\n- `NotifyStates` supports channel routing (`audience.channels`).\n- If the instance `Channel` is `*` or `all`, routing is disabled (match-all): it sees all messages.\n- If the instance `Channel` is empty, it only sees **unscoped** messages (messages without `audience.channels.include`).\n- If the instance `Channel` is set (example: `Family`), it sees:\n  - unscoped messages, and\n  - messages that include that channel,\n  - but it does not see messages that exclude that channel.\n- This applies to incoming notifications *and* to `fullJson` and `Stats.*`.\n\nCommon options:\n\n- `blobIntervalMs` (number, ms, default `300000`)\n  - Interval for writing `*.fullJson` snapshots. Use `0` to disable.\n- `statsMinIntervalMs` (number, ms, default `1000`)\n  - Throttle statistics updates triggered by notifications. Use `0` to disable throttling.\n- `statsMaxIntervalMs` (number, ms, default `300000`)\n  - Force a periodic stats refresh even without notifications. Use `0` to disable.\n- `mapTypeMarker` (string, default `__msghubType`)\n  - Overrides the marker used by `serializeWithMaps` (advanced).\n\n`kindKey` and `levelKey` in the state ids come from the **keys** of `MsgConstants.kind` / `MsgConstants.level`.\n\n### Best practices\n\n- Keep `blobIntervalMs=0` unless you really need full snapshots (it can create large states).\n- Use `Latest.*` / `byKind.*` / `byLevel.*` for automations (small payloads) and dashboards.\n- Use `Stats.*` for fast dashboards and health indicators.\n\n### Troubleshooting\n\n- “No states show up”\n  - Verify the plugin instance is enabled and running.\n  - Check adapter logs for warnings about object creation (`setObjectNotExists`) or state writes.\n\n- “States update but JSON looks strange”\n  - Notifications can contain `Map` values (for example `metrics`); `NotifyStates` serializes those with `serializeWithMaps`.\n\n---",
    "source": "docs/plugins/NotifyStates.md"
  }
}
