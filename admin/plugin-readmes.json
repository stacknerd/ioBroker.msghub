{
  "BridgeAlexaShopping": {
    "md": "### What it does\n\n- Creates and maintains one Message Hub message (`kind: shoppinglist`) representing your Alexa list.\n- Keeps changes in sync:\n  - Alexa ‚Üí Message Hub (ingest)\n  - Message Hub ‚Üí Alexa (write-back)\n- Optional: assigns a `category` to list items using Message Hub AI (when enabled).\n\nWhat it intentionally does not do (today):\n\n- It does not aggregate duplicates like ‚ÄúButter‚Äù + ‚ÄúButter‚Äù into a single item with a quantity.\n- It does not parse quantities/units from item text (e.g. ‚Äú2x‚Äù, ‚Äú500g‚Äù).\n\n### Prerequisites\n\n- `iobroker.alexa2` must be installed and running.\n- You need an Alexa list state that contains the list as a JSON array, typically:\n  - `alexa2.0.Lists.<LISTNAME>.json`\n- For write-back, your `alexa2` installation must expose the command states derived from that list id (see below).\n\nIf you want AI categories:\n\n- The Message Hub adapter must have AI enabled in its instance config (provider + API key).\n- The plugin option `aiEnhancement` must be enabled.\n\n### Quick start (recommended setup)\n\n1. Make sure the Alexa list JSON state exists and contains an array (in ioBroker Admin ‚Üí Objects).\n2. Create one `BridgeAlexaShopping` instance in the Message Hub Plugins tab.\n3. Set:\n   - `jsonStateId` to your Alexa list JSON state\n   - `listTitle` to a human-friendly name\n   - `fullSyncIntervalMs` to something reasonable (example: `3600000` = 1 hour)\n4. Enable the plugin instance (`...enable` switch).\n5. Watch the resulting Message Hub message:\n   - Items from Alexa should appear as `listItems`.\n6. Test write-back:\n   - Add an item in the Message Hub list ‚Üí it should appear in Alexa after the next sync.\n\n### How to configure\n\nConfiguration is done in the Message Hub Admin Tab (Plugins) and uses the schema from `lib/BridgeAlexaShopping/manifest.js`.\n\nRequired / common options:\n\n- `jsonStateId` (string)\n  - The Alexa list JSON state (example: `alexa2.0.Lists.SHOP.json`).\n  - This single option also determines the write-back command ids (derived from `jsonStateId` without the `.json` suffix).\n- `listTitle` (string)\n  - The Message Hub message title.\n- `location` (string)\n  - Written to `details.location` of the message.\n- `audienceTagsCsv` (string, CSV)\n  - Comma-separated tags copied to `audience.tags`.\n- `fullSyncIntervalMs` (number)\n  - Periodic full reconciliation interval; `0` disables the periodic run.\n- `conflictWindowMs` (number)\n  - Conflict debounce window after write-back (see best practices below).\n- `keepCompleted` (number, ms)\n  - Retention time for completed items.\n  - After this duration, completed items are deleted (in Message Hub and therefore also in Alexa).\n  - Use `0` to never delete completed items.\n\nAI options:\n\n- `aiEnhancement` (boolean)\n  - Enables optional AI enrichment (category assignment).\n- `categoriesCsv` (string, CSV)\n  - The list of allowed categories.\n  - The last entry is treated as the fallback category.\n- `aiMinConfidencePct` (number)\n  - Minimum confidence (0..100) for accepting an AI category.\n  - When below this threshold, the fallback category is used.\n\n### How to find the correct `jsonStateId`\n\nIn ioBroker Admin:\n\n- Open the Objects tab.\n- Search for `alexa2.0.Lists.` and look for states ending in `.json`.\n- Pick the list you want to sync (example: `alexa2.0.Lists.SHOP.json`).\n\nThe value must be a JSON array of items with (at least) `id`, `value`, and `completed` fields. If it is not an array,\nthe plugin treats it as empty.\n\n### Write-back (how Alexa commands are addressed)\n\nWrite-back uses `setForeignState(...)` to these ids (derived from `jsonStateId`):\n\nLet `base = jsonStateId` without the trailing `.json`.\n\n- Create: `base.#New` or `base.#create` (value = item text; the plugin auto-detects which command state exists)\n- Rename: `base.items.<itemId>.value` (value = new text)\n- Toggle completion: `base.items.<itemId>.completed` (value = `true|false`)\n- Delete: `base.items.<itemId>.#delete` (value = `true`)\n\nExample for `jsonStateId = alexa2.0.Lists.SHOP.json`:\n\n- `alexa2.0.Lists.SHOP.#New` (or `alexa2.0.Lists.SHOP.#create`)\n- `alexa2.0.Lists.SHOP.items.<itemId>.value`\n- `alexa2.0.Lists.SHOP.items.<itemId>.completed`\n- `alexa2.0.Lists.SHOP.items.<itemId>.#delete`\n\n### How to verify write-back is working\n\nUse ioBroker Admin ‚Üí Objects:\n\n- Check that the derived command states exist under the same list base (without `.json`).\n- When you add or change an item in Message Hub, you should see writes to:\n  - `...#New` (or `...#create`) for new items\n  - `...items.<id>.value` for renames\n  - `...items.<id>.completed` for check/uncheck\n  - `...items.<id>.#delete` for deletions\n\nIf these command states do not exist in your `alexa2` installation, Message Hub can still read the list, but cannot\nwrite back to Alexa.\n\n### Best practices\n\n- Prefer one plugin instance per Alexa list.\n- Keep `jsonStateId` stable. Changing it changes the message `ref` and resets the mapping for that instance.\n- Use `fullSyncIntervalMs` even when state-change events are working:\n  - It acts as a periodic reconciliation and helps recover from missed events or temporary connectivity issues.\n- Keep completed-item cleanup explicit:\n  - Use `keepCompleted=0` to keep completed items forever.\n  - Use a finite value (example: `12 * 60 * 60 * 1000`) to automatically delete completed items after that time.\n  - Deletion is enforced during reconciliation (`fullSyncIntervalMs`) and on inbound list updates.\n- Avoid manual edits to internal states:\n  - `msghub.0.BridgeAlexaShopping.<instanceId>.mapping`\n  - `msghub.0.BridgeAlexaShopping.<instanceId>.categories`\n  These states are intentionally marked read-only (for users); the adapter still writes to them internally.\n- Conflicts and loops:\n  - If you have other automations writing to the same Alexa list, keep `conflictWindowMs` at a non-zero value (default `5000`).\n  - This reduces ‚Äúping-pong‚Äù updates by enforcing Message Hub as the source of truth after write-back.\n- AI categories:\n  - If `aiEnhancement` is enabled in the plugin but AI is disabled in the adapter instance config, category assignment is skipped (no errors; it just does nothing).\n  - Keep `categoriesCsv` small and stable. Changing the list resets the learned cache for that plugin instance.\n  - Pick categories that match how you actually shop. Example set:\n    - `Produce,Bakery,Dairy,Meat,Frozen,Pantry,Drinks,Household,Hygiene,Other`\n\n### Operational notes\n\n- Disable behavior:\n  - When you disable the plugin instance, the Message Hub message is kept.\n  - The title is updated with a ‚Äúconnection lost‚Äù suffix (to make the inactive state visible).\n- Managed state reporting:\n  - The plugin reports the monitored `jsonStateId` as a managed state (metadata stamping + watchlist) so you can see\n    which external state is used by this plugin instance.\n\n### Troubleshooting\n\nCommon symptoms and what to check:\n\n- ‚ÄúNothing appears in Message Hub‚Äù\n  - Verify `jsonStateId` exists and contains a JSON array.\n  - Check whether the plugin instance is enabled and running.\n  - Trigger a manual change in the Alexa list and confirm the `.json` state updates.\n\n- ‚ÄúItems appear in Message Hub but do not write back to Alexa‚Äù\n  - Verify the derived command states exist (see ‚ÄúWrite-back‚Äù section).\n  - Check adapter logs for warnings about `setForeignState` failures.\n\n- ‚ÄúItems oscillate / ping-pong between values‚Äù\n  - Increase `conflictWindowMs` (start with the default `5000`).\n  - Reduce other automations that write to the same list, or ensure they do not fight Message Hub.\n\n- ‚ÄúAI categories do not show up‚Äù\n  - Confirm AI is enabled in the Message Hub adapter instance config and a valid API key is set.\n  - Confirm `aiEnhancement=true` and `categoriesCsv` is not empty in the plugin instance config.\n  - Note: AI categorization is best-effort; if AI is unavailable, syncing still works (without categories).\n\n---",
    "source": "docs/plugins/BridgeAlexaShopping.md"
  },
  "BridgeAlexaTasks": {
    "md": "### What it does\n\n- Imports new Alexa TODO items into Message Hub as tasks (Alexa ‚Üí Message Hub).\n- Mirrors a filtered subset of Message Hub messages back into the Alexa TODO list (Message Hub ‚Üí Alexa).\n- Optional: generates a concise title for imported tasks using Message Hub AI (when enabled).\n\nWhat it intentionally does not do:\n\n- It does not sync edits from Alexa back into Message Hub for mirrored tasks (Alexa is display-only for outbound items).\n- It does not attempt to preserve lifecycle semantics on the Alexa side (Alexa does not have Message Hub lifecycle states).\n\n### Prerequisites\n\n- `iobroker.alexa2` must be installed and running.\n- You need an Alexa list state that contains the list as a JSON array, typically:\n  - `alexa2.0.Lists.<LISTNAME>.json` (default: `alexa2.0.Lists.TODO.json`)\n- For write-back (mirroring), your `alexa2` installation must expose the command states derived from that list id (see below).\n\nIf you want AI titles:\n\n- The Message Hub adapter must have AI enabled in its instance config (provider + API key).\n- The plugin option `aiEnhancedTitle` must be enabled.\n\n### Quick start (recommended setup)\n\n1. Make sure the Alexa TODO list JSON state exists and contains an array (in ioBroker Admin ‚Üí Objects).\n2. Create one `BridgeAlexaTasks` instance in the Message Hub Plugins tab.\n3. Set:\n   - `jsonStateId` to your Alexa list JSON state\n   - `fullSyncIntervalMs` to something reasonable (example: `3600000` = 1 hour)\n   - `outEnabled` depending on whether you want mirroring back to Alexa\n4. Enable the plugin instance (`...enable` switch).\n5. Add an item in Alexa:\n   - It should appear in Message Hub as a new `task` message.\n   - It should then be deleted from the Alexa TODO list (inbox semantics).\n\n### How to configure\n\nConfiguration is done in the Message Hub Admin Tab (Plugins) and uses the schema from `lib/BridgeAlexaTasks/manifest.js`.\n\nCommon options:\n\n- `jsonStateId` (string)\n  - The Alexa list JSON state (example: `alexa2.0.Lists.TODO.json`).\n  - This single option also determines the write-back command ids (derived from `jsonStateId` without the `.json` suffix).\n- `fullSyncIntervalMs` (number)\n  - Periodic full reconciliation interval; `0` disables the periodic run.\n- `audienceTagsCsv` (string, CSV)\n  - Comma-separated tags copied to `audience.tags` for imported tasks.\n- `aiEnhancedTitle` (boolean)\n  - When enabled and AI is available, the plugin generates a concise title for imported tasks.\n\nOutbound mirroring (projection) options:\n\n- `outEnabled` (boolean)\n  - Enables mirroring tasks back to Alexa.\n  - If you disable it, the plugin removes all previously mirrored items from Alexa on the next reconciliation run.\n- `outKindsCsv` (string, CSV)\n  - Which message kinds may be mirrored (default `task`).\n- `outLevelMin` / `outLevelMax` (number)\n  - Inclusive message level range for mirroring.\n- `outLifecycleStatesCsv` (string, CSV)\n  - Allowed lifecycle states (default `open`).\n- `outAudienceTagsAnyCsv` (string, CSV)\n  - Optional tag filter: message must have at least one matching `audience.tags` entry.\n\n### How to find the correct `jsonStateId`\n\nIn ioBroker Admin:\n\n- Open the Objects tab.\n- Search for `alexa2.0.Lists.` and look for states ending in `.json`.\n- Pick the list you want to use (example: `alexa2.0.Lists.TODO.json`).\n\nThe value must be a JSON array of items with (at least) `id`, `value`, and `completed` fields. If it is not an array,\nthe plugin treats it as empty.\n\n### Write-back (how Alexa commands are addressed)\n\nWrite-back uses `setForeignState(...)` to these ids (derived from `jsonStateId`):\n\nLet `base = jsonStateId` without the trailing `.json`.\n\n- Create: `base.#New` or `base.#create` (value = item text; the plugin auto-detects which command state exists)\n- Rename/update: `base.items.<itemId>.value` (value = new text)\n- Mark completed: `base.items.<itemId>.completed` (value = `true|false`)\n- Delete: `base.items.<itemId>.#delete` (value = `true`)\n\n### How to verify write-back is working\n\nUse ioBroker Admin ‚Üí Objects:\n\n- Check that the derived command states exist under the same list base (without `.json`).\n- When mirroring is enabled (`outEnabled=true`), you should see writes to:\n  - `...#New` (or `...#create`) for new mirrored items\n  - `...items.<id>.value` when a mirrored item changes\n  - `...items.<id>.#delete` when an item is removed from the projection\n\nIf these command states do not exist in your `alexa2` installation, Message Hub can still import tasks from Alexa,\nbut cannot mirror tasks back to Alexa.\n\n### Best practices\n\n- Use one plugin instance per Alexa list.\n- Keep `jsonStateId` stable for a plugin instance.\n- Use a periodic `fullSyncIntervalMs` even when state-change events are working:\n  - It acts as a reconciliation loop and helps recover from missed events.\n- Treat Alexa as a quick task inbox:\n  - Add tasks in Alexa, then manage them in Message Hub.\n- Keep the outbound filter narrow:\n  - Default idea: only `kind=task`, `level>=10`, `lifecycle=open`.\n\n### Operational notes\n\n- Inbound import semantics:\n  - If import succeeds, the plugin deletes the Alexa item.\n  - If import fails, the plugin marks the Alexa item as completed to avoid repeated imports.\n- Disabling outbound mirroring:\n  - When `outEnabled=false`, all previously mirrored items are removed from Alexa on the next reconciliation run.\n- Managed state reporting:\n  - The plugin reports the monitored `jsonStateId` as a managed state (metadata stamping + watchlist).\n\n### Troubleshooting\n\nCommon symptoms and what to check:\n\n- ‚ÄúItems in Alexa are not imported‚Äù\n  - Verify `jsonStateId` exists and contains a JSON array.\n  - Check whether the plugin instance is enabled and running.\n  - Trigger a manual change in the Alexa list and confirm the `.json` state updates.\n\n- ‚ÄúMirroring to Alexa does not work‚Äù\n  - Verify the derived command states exist (see ‚ÄúWrite-back‚Äù section).\n  - Confirm `outEnabled=true`.\n\n- ‚ÄúAI titles do not show up‚Äù\n  - Confirm AI is enabled in the Message Hub adapter instance config and a valid API key is set.\n  - Confirm `aiEnhancedTitle=true` in the plugin instance config.\n  - Note: AI enrichment is best-effort; importing still works without AI.\n\n---",
    "source": "docs/plugins/BridgeAlexaTasks.md"
  },
  "IngestRandomChaos": {
    "md": "### What it does\n\n- Periodically creates, updates, and removes a small pool of messages.\n- Generates both `task` and `status` messages with plausible lifecycle transitions.\n- Cleans up after itself on stop by soft-deleting messages it managed in the current run.\n\nWhat it intentionally does not do:\n\n- It is not deterministic and not a strict simulator.\n- It does not try to cover every message feature (for example no `listItems`, `actions`, `attachments`, ...).\n\n### Prerequisites\n\n- None. This plugin is self-contained and does not read foreign states.\n\n### Quick start (recommended setup)\n\n1. Create an `IngestRandomChaos` instance in the Message Hub Plugins tab.\n2. Keep the defaults or set reasonable values:\n   - `intervalMinMs=2000`\n   - `intervalMaxMs=5000`\n   - `maxPool=10`\n3. Enable the plugin instance (`...enable` switch).\n4. Watch the Message Hub message list and/or notifier outputs (for example `NotifyStates`).\n\n### How to configure\n\nConfiguration is done in the Message Hub Admin Tab (Plugins) and uses the schema from `lib/IngestRandomChaos/manifest.js`.\n\nOptions:\n\n- `intervalMinMs` (number, ms, default `2000`)\n  - Minimum delay between ticks.\n- `intervalMaxMs` (number, ms, default `5000`)\n  - Maximum delay between ticks (clamped to be `>= intervalMinMs`).\n- `maxPool` (number, default `10`)\n  - Maximum number of concurrently ‚Äúactive‚Äù messages managed by this plugin.\n\n### Best practices\n\n- Use this plugin for development/testing only; keep it disabled in production.\n- Keep `maxPool` small to avoid archive spam and to keep notifier/state churn manageable.\n- Pair it with notifier plugins (for example `NotifyStates`) to validate routing behavior.\n\n### Troubleshooting\n\n- ‚ÄúNothing happens‚Äù\n  - Verify the plugin instance is enabled and running.\n  - Ensure `intervalMaxMs` is not accidentally set below `intervalMinMs`.\n\n- ‚ÄúToo many messages‚Äù\n  - Reduce `maxPool` and/or increase the intervals.\n\n---",
    "source": "docs/plugins/IngestRandomChaos.md"
  },
  "IngestStates": {
    "md": "### What it does\n\n- Scans `system/custom` for objects that have MsgHub custom settings (`common.custom.<msghub instance>`).\n- Subscribes to the configured datapoints (and selected dependencies).\n- For `mode=\"freshness\"`:\n  - creates a message when updates stop for too long\n  - optionally repeats via `msg.remind*`\n  - optionally auto-closes on recovery via `msg.resetOnNormal` (+ delay)\n\n### How to configure (ioBroker Admin)\n\n1. Enable the `IngestStates` plugin instance in the MsgHub Admin Tab (Plugins).\n2. In ioBroker Admin ‚Üí Objects, open a datapoint and go to **Custom**.\n3. Enable the MsgHub custom config for your adapter instance (e.g. `msghub.0`).\n4. Set:\n   - `mode = freshness`\n   - `fresh.everyValue` + `fresh.everyUnit`\n   - `fresh.evaluateBy = ts|lc`\n   - optional: `msg.level`, `msg.kind`, `msg.title`, `msg.text`, `msg.remind*`, `msg.resetOnNormal`\n\n### Notes\n\n- `ts` (last update) changes on every write; `lc` (last change) only on value changes.\n- If you enable custom but keep `mode` empty, MsgHub may auto-disable that custom entry to avoid ‚Äúenabled but misconfigured‚Äù setups.\n\n---",
    "source": "docs/plugins/IngestStates.md"
  },
  "NotifyDebug": {
    "md": "### What it does\n\n- Logs plugin lifecycle (`start(ctx)`, `stop(ctx)`) when trace is enabled.\n- Logs every notification batch received via `onNotifications(event, notifications, ctx)`.\n- Does not deliver anything and does not modify the Message Hub store.\n\n### Prerequisites\n\n- None. You only need access to the Message Hub adapter logs.\n\n### Quick start (recommended setup)\n\n1. Create a `NotifyDebug` instance in the Message Hub Plugins tab.\n2. Set `trace=true`.\n3. Enable the plugin instance (`...enable` switch).\n4. Trigger a notification (for example by creating/updating a message) and watch the adapter logs.\n\n### How to configure\n\nConfiguration is done in the Message Hub Admin Tab (Plugins) and uses the schema from `lib/NotifyDebug/manifest.js`.\n\nOptions:\n\n- `trace` (boolean, default `false`)\n  - Enables debug logs for start/stop and dispatches.\n- `someText` (string, default `\"\"`)\n  - Optional demo value logged at startup.\n\n### Best practices\n\n- Keep this plugin disabled in production; it can produce noisy logs.\n- Use it temporarily when developing other plugins or diagnosing notification routing.\n\n### Troubleshooting\n\n- ‚ÄúNo logs‚Äù\n  - Verify `trace=true` and the plugin instance is enabled and running.\n  - Check adapter log level; `NotifyDebug` uses `debug` and `info`.\n\n---",
    "source": "docs/plugins/NotifyDebug.md"
  },
  "NotifyPushover": {
    "md": "### What it does\n\n- Sends Message Hub notifications (`event: \"due\"`) to `iobroker.pushover` (or compatible) via `sendTo('<pushover.0>', 'send', payload)`.\n- Filters which messages are sent (kind, level range, lifecycle states, audience tags).\n- Optional: blocks delivery behind a gate state (presence/arming/etc.).\n- If a message has image attachments, sends one additional low-priority Pushover message per image.\n\nWhat it intentionally does not do:\n\n- It does not send `added/updated/deleted/expired` events (only `due`).\n- It does not implement rate limiting or ‚Äúspam protection‚Äù.\n- It does not download images: only local plain file paths are accepted for image attachments.\n\n### Prerequisites\n\n- A running Pushover adapter instance (example: `pushover.0`) with working credentials.\n- Message Hub must be running and the plugin instance must be enabled.\n\n### Quick start (recommended setup)\n\n1. Create one `NotifyPushover` instance in the Message Hub Plugins tab.\n2. Set:\n   - `pushoverInstance` to your adapter instance (default: `pushover.0`)\n   - optionally: filters (`kindsCsv`, `levelMin/max`, `lifecycleStatesCsv`, `audienceTagsAnyCsv`)\n   - priorities/icons to match your desired urgency mapping\n3. Optional gate:\n   - set `gateStateId` and a `gateOp` (and `gateValue` if needed)\n4. Enable the plugin instance (`...enable` switch).\n5. Make a message due (or create one without `timing.notifyAt`) and verify the Pushover notification arrives.\n\n### How to configure\n\nConfiguration is done in the Message Hub Admin Tab (Plugins) and uses the schema from `lib/NotifyPushover/manifest.js`.\n\nTarget:\n\n- `pushoverInstance` (string)\n  - The adapter instance to call via `sendTo`, e.g. `pushover.0`.\n\nMessage filters (all optional; empty = allow all):\n\n- `kindsCsv` (string, CSV)\n  - Filters by `message.kind` (example: `task,status,appointment`).\n- `levelMin` / `levelMax` (number)\n  - Inclusive level range.\n- `lifecycleStatesCsv` (string, CSV)\n  - Filters by `message.lifecycle.state` (example: `open,acked,closed,snoozed,deleted,expired`).\n- `audienceTagsAnyCsv` (string, CSV)\n  - If set, only messages with at least one matching `audience.tags` entry are sent.\n\nPriority + title icons (per message level):\n\n- `priorityNone` / `priorityNotice` / `priorityWarning` / `priorityError` (number)\n  - Per-level Pushover priority mapping (`-1` low, `0` normal, `1` high).\n- `iconNone` / `iconNotice` / `iconWarning` / `iconError` (string)\n  - Prefix icons used in the Pushover `title` (example defaults: `‚ùî`, `‚ÑπÔ∏è`, `‚ö†Ô∏è`, `üõë`).\n\nGate (optional):\n\n- `gateStateId` (string)\n  - A foreign state id used as a gate (example: presence state).\n- `gateOp` (string)\n  - One of: `>`, `<`, `=`, `true`, `false`.\n  - Empty disables the gate.\n- `gateValue` (string)\n  - Comparison value for `>`, `<`, `=` (numeric or string).\n  - Ignored for `true` / `false`.\n- `gateBypassFromLevel` (number)\n  - If `message.level >= gateBypassFromLevel`, the gate is bypassed and the notification is always sent.\n  - Default: `99` (effectively disabled for built-in levels 0/10/20/30).\n\n### How to find the correct `pushoverInstance`\n\nIn ioBroker Admin:\n\n- Open the Instances tab.\n- Find your Pushover adapter instance.\n- Use the instance id as value (example: `pushover.0`).\n\n### Gate examples\n\nPresence boolean gate (only send when `true`):\n\n- `gateStateId = some.0.presence`\n- `gateOp = true`\n\nNumeric threshold gate (only send when value is greater than 0):\n\n- `gateStateId = some.0.presenceCount`\n- `gateOp = >`\n- `gateValue = 0`\n\n### Troubleshooting\n\n- ‚ÄúNo notifications arrive‚Äù\n  - Verify the plugin instance is enabled and `Status` is `running`.\n  - Verify your Pushover adapter instance can receive `sendTo(..., 'send', ...)` commands (test with an existing script).\n  - Confirm messages are actually dispatched as `due` (Message Hub may treat missing `notifyAt` as ‚Äúdue now‚Äù).\n\n- ‚ÄúImages do not arrive‚Äù\n  - Only attachments with `type: \"image\"` and a local plain file path (`value` without `://`) are sent.\n  - URLs are ignored by design.\n\n---",
    "source": "docs/plugins/NotifyPushover.md"
  },
  "NotifyShoppingPdf": {
    "md": "### What it does\n\n- Listens to MsgHub notifications for `shoppinglist` messages (`added`, `updated`, `deleted`, `expired`).\n- Regenerates a single combined PDF (debounced/throttled via `renderDebounceMs`).\n- Stores the PDF in ioBroker file storage under `msghub.0/documents/NotifyShoppingPdf.<instanceId>.pdf`.\n\n### What it intentionally does not do\n\n- No fallbacks outside the MsgHub runtime (`IoPlugins`): it expects `ctx.api.*` capabilities and the adapter environment.\n- No PDF rendering without LaTeX: `pdflatex` must be available.\n- No sorting: shopping lists and items are rendered ‚Äúas delivered‚Äù by MsgHub.\n\n### Prerequisites\n\n- `pdflatex` must be installed and available on `PATH`.\n- The LaTeX template uses packages like `tcolorbox`, `multicol`, `tabularx`, `fancyhdr`, `lastpage` (Debian often needs `texlive-latex-extra`).\n- The Message Hub adapter must be running and have shopping list messages (`kind: shoppinglist`) in the store.\n\nIf `pdflatex` is missing, the plugin fails to start and the instance stays in `error`.\n\nExample (Debian):\n\n```sh\nsudo apt-get install texlive-latex-base texlive-latex-extra\n```\n\n### Output location (ioBroker file storage)\n\nThe plugin writes one PDF per plugin instance:\n\n- `msghub.0/documents/NotifyShoppingPdf.<instanceId>/<pdfTitle>.pdf`\n\nExample:\n\n- `msghub.0/documents/NotifyShoppingPdf.0/Einkaufsliste.pdf`\n\nYou can view/download it via ioBroker Admin ‚Üí Files (or any integration that can read adapter file storage).\n\n### States written by the plugin\n\nAfter every successful generation, the plugin writes two states below its instance subtree:\n\n- `msghub.0.NotifyShoppingPdf.<instanceId>.pdfPath`\n  - Value: `msghub.0/documents/NotifyShoppingPdf.<instanceId>/<pdfTitle>.pdf`\n- `msghub.0.NotifyShoppingPdf.<instanceId>.pdfUrl`\n  - Best-effort URL to the PDF:\n    - If `web.0` is detected: `http(s)://<host>:<port>/files/msghub.0/documents/...`\n    - Otherwise: `/files/msghub.0/documents/...` (relative path)\n\n### Configuration\n\nConfiguration is done in the Message Hub Admin Tab (Plugins) and uses the schema from `lib/NotifyShoppingPdf/manifest.js`.\n\nCommon options:\n\n- `includeChecked` (boolean; default `true`)\n  - When enabled, checked items are included (rendered greyed out).\n- `refsWhitelistCsv` (string CSV; default empty)\n  - Comma-separated message refs to include.\n  - Empty means ‚Äúinclude all shopping lists‚Äù.\n- `refsBlacklistCsv` (string CSV; default empty)\n  - Comma-separated message refs to exclude.\n  - Blacklist wins over whitelist.\n- `renderDebounceMs` (number; default `1000`)\n  - Debounce window for regenerating the PDF when notifications arrive.\n- `printRoomLabelsFromItems` (number; default `6`)\n  - Prints `listItem.category` section headings only when the list has more than this number of printed items.\n- `includeEmptyCategories` (boolean; default `true`)\n  - If disabled, lists with 0 printed items are omitted from the PDF.\n- `design` (string; default `print`)\n  - `screen` uses lighter lines; `print` uses stronger lines.\n- `notesLines` (number; default `5`)\n  - Adds a localized ‚ÄúNOTES/NOTIZEN‚Äù block at the end of the PDF (`0` disables it).\n\n### How the PDF layout maps to MsgHub data\n\n- **Category cards** in the PDF correspond to shopping list messages.\n  - `category` label = `message.title` (fallback: `message.ref`).\n- Inside each card, **rooms/sections** correspond to list item categories:\n  - `room.label` = `listItem.category` (fallback: `uncategorizedLabel`).\n- Each printed line corresponds to one `listItems[]` entry and shows a checkbox:\n  - `checked=false` ‚Üí empty box\n  - `checked=true` ‚Üí checkmark (and greyed out text if `includeChecked=true`)\n\nThe PDF subtitle is a localized ‚Äúgenerated at‚Äù timestamp derived from `system.config.common.language`\n(example: `Sonntag, 04.01.2026 02:10`).\n\n---",
    "source": "docs/plugins/NotifyShoppingPdf.md"
  },
  "NotifyStates": {
    "md": "### What it does\n\n- Writes the most recent notification payload into ioBroker states, grouped by:\n  - event (`Latest.<event>`)\n  - kind (`byKind.<kindKey>.<event>`)\n  - level (`byLevel.<levelKey>.<event>`)\n- Optionally writes periodic snapshots of the full Message Hub store (`fullJson`).\n- Maintains simple counters (`Stats.*`) so you can build dashboards without parsing large JSON blobs.\n\nWhat it intentionally does not do:\n\n- It does not keep a history/log (each state is ‚Äúlast write wins‚Äù).\n- It does not deduplicate or aggregate notifications.\n\n### Prerequisites\n\n- None beyond a working Message Hub instance. The produced states can be consumed by scripts/visualizations/automations.\n\n### Quick start (recommended setup)\n\n1. Create a `NotifyStates` instance in the Message Hub Plugins tab.\n2. Enable the plugin instance (`...enable` switch).\n3. Inspect the generated states in ioBroker Admin ‚Üí Objects under:\n   - `msghub.0.NotifyStates.<instanceId>.Latest.*`\n4. Trigger a notification (for example create/update a message) and observe state updates.\n\n### How to configure\n\nConfiguration is done in the Message Hub Admin Tab (Plugins) and uses the schema from `lib/NotifyStates/manifest.js`.\n\nCommon options:\n\n- `blobIntervalMs` (number, ms, default `300000`)\n  - Interval for writing `*.fullJson` snapshots. Use `0` to disable.\n- `statsMinIntervalMs` (number, ms, default `1000`)\n  - Throttle statistics updates triggered by notifications. Use `0` to disable throttling.\n- `statsMaxIntervalMs` (number, ms, default `300000`)\n  - Force a periodic stats refresh even without notifications. Use `0` to disable.\n- `mapTypeMarker` (string, default `__msghubType`)\n  - Overrides the marker used by `serializeWithMaps` (advanced).\n\n`kindKey` and `levelKey` in the state ids come from the **keys** of `MsgConstants.kind` / `MsgConstants.level`.\n\n### Best practices\n\n- Keep `blobIntervalMs=0` unless you really need full snapshots (it can create large states).\n- Use `Latest.*` / `byKind.*` / `byLevel.*` for automations (small payloads) and dashboards.\n- Use `Stats.*` for fast dashboards and health indicators.\n\n### Troubleshooting\n\n- ‚ÄúNo states show up‚Äù\n  - Verify the plugin instance is enabled and running.\n  - Check adapter logs for warnings about object creation (`setObjectNotExists`) or state writes.\n\n- ‚ÄúStates update but JSON looks strange‚Äù\n  - Notifications can contain `Map` values (for example `metrics`); `NotifyStates` serializes those with `serializeWithMaps`.\n\n---",
    "source": "docs/plugins/NotifyStates.md"
  }
}
